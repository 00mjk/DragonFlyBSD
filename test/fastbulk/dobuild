#!/bin/csh
#
# This is run from the chroot via fastbulk, which has CDd
# into a particular pkgsrc directory and wants us to build it.

# Nothing to do if the package already exists.  Remove the run log
# to prevent fastbulk from replacing the log from a previous run
#
set pkgname = "`bmake show-var VARNAME=PKGNAME`"
set logname = $argv[1]
unsetenv PKG_PATH

# Check if already installed, prevent overwrite of
# previous run's logfile if it exists, else put in
# a simple logfile.
#
pkg_info -q -e $pkgname
if ( $status == 0 ) then
    if ( -f /tmp/logs/good/$logname ) then
	rm -f /tmp/logs/run/$logname
    endif
    echo "(already installed from previous run)"
    exit 0
endif

if ( -f /usr/pkgsrc/packages/All/${pkgname}.tgz ) then
    echo "(found in /usr/pkgsrc/packages)"
    bmake deinstall DEINSTALLDEPENDS=ALL SKIP_LICENSE_CHECK=yes
    setenv PKG_PATH /usr/pkgsrc/packages/All
    echo "pkg_add -f ${pkgname}"
    pkg_add -f ${pkgname}
    exit $status
endif

# We have to remove any conflicting packages or the one we
# are trying to build will refuse to build.  Note that we
# leave the related packages intact.
#
foreach i ( `bmake show-var VARNAME=CONFLICTS` )
    echo "DELETING CONFLICTING PACKAGE: $i"
    pkg_delete -r "$i"
end

# To ensure a clean build deinstall anything that
# may cause our build repackage to fail.
#
# Clean after repackaging (if it succeeded) to keep the
# work topology footprint small.  The work topology is
# left intact for failed builds.
#
bmake deinstall DEINSTALLDEPENDS=ALL SKIP_LICENSE_CHECK=yes
bmake repackage clean SKIP_LICENSE_CHECK=yes
if ( $status == 0 ) then
    setenv PKG_PATH /usr/pkgsrc/packages/All
    echo "pkg_add -f ${pkgname}"
    pkg_add -f ${pkgname}
    exit $status
endif
exit 1
