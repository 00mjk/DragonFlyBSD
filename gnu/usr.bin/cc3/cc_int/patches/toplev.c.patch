$DragonFly: src/gnu/usr.bin/cc3/cc_int/patches/Attic/toplev.c.patch,v 1.1 2004/03/05 21:38:44 joerg Exp $
Index: toplev.c
===================================================================
RCS file: /cvs/src/contrib/gcc-3.3/gcc/toplev.c,v
retrieving revision 1.1
diff -u -r1.1 toplev.c
--- toplev.c	2 Feb 2004 23:09:50 -0000	1.1
+++ toplev.c	4 Mar 2004 15:18:48 -0000
@@ -904,6 +904,15 @@
    minimum function alignment.  Zero means no alignment is forced.  */
 int force_align_functions_log;
 
+#if defined(STACK_PROTECTOR) && defined(STACK_GROWS_DOWNWARD)
+/* Nonzero means use propolice as a stack protection method */
+int flag_propolice_protection = 1;
+int flag_stack_protection = 0;
+#else
+int flag_propolice_protection = 0;
+int flag_stack_protection = 0;
+#endif
+
 /* Table of supported debugging formats.  */
 static const struct
 {
@@ -1188,6 +1197,10 @@
    N_("Trap for signed overflow in addition / subtraction / multiplication") },
   { "new-ra", &flag_new_regalloc, 1,
    N_("Use graph coloring register allocation.") },
+  {"stack-protector", &flag_propolice_protection, 1,
+   N_("Enables stack protection") },
+  {"stack-protector-all", &flag_stack_protection, 1,
+   N_("Enables stack protection of every function") } ,
 };
 
 /* Table of language-specific options.  */
@@ -1547,7 +1560,9 @@
   {"missing-noreturn", &warn_missing_noreturn, 1,
    N_("Warn about functions which might be candidates for attribute noreturn") },
   {"strict-aliasing", &warn_strict_aliasing, 1,
-   N_ ("Warn about code which might break the strict aliasing rules") }
+   N_ ("Warn about code which might break the strict aliasing rules") },
+  {"stack-protector", &warn_stack_protector, 1,
+   N_("Warn when disabling stack protector for some reason")}
 };
 
 void
@@ -2449,6 +2464,8 @@
 
       insns = get_insns ();
 
+      if (flag_propolice_protection) prepare_stack_protection (inlinable);
+  
       /* Dump the rtl code if we are dumping rtl.  */
 
       if (open_dump_file (DFI_rtl, decl))
@@ -5223,6 +5240,12 @@
     /* The presence of IEEE signaling NaNs, implies all math can trap.  */
     if (flag_signaling_nans)
       flag_trapping_math = 1;
+
+    /* This combination makes optimized frame addressings and causes
+       a internal compilation error at prepare_stack_protection.
+       so don't allow it.  */
+    if (flag_stack_protection && !flag_propolice_protection)
+      flag_propolice_protection = TRUE;
 }
 
 /* Initialize the compiler back end.  */
