$DragonFly: src/gnu/usr.bin/cc3/cc_int/patches/Attic/cse.c.patch,v 1.1 2004/03/05 21:38:44 joerg Exp $
Index: cse.c
===================================================================
RCS file: /cvs/src/contrib/gcc-3.3/gcc/cse.c,v
retrieving revision 1.1
diff -u -r1.1 cse.c
--- cse.c	2 Feb 2004 23:09:47 -0000	1.1
+++ cse.c	4 Mar 2004 15:18:25 -0000
@@ -4288,7 +4288,14 @@
 
 	      if (new_const == 0)
 		break;
-
+#ifndef FRAME_GROWS_DOWNWARD
+	      if (flag_propolice_protection
+		  && GET_CODE (y) == PLUS
+		  && XEXP (y, 0) == frame_pointer_rtx
+		  && INTVAL (inner_const) > 0
+		  && INTVAL (new_const) <= 0)
+		break;
+#endif
 	      /* If we are associating shift operations, don't let this
 		 produce a shift of the size of the object or larger.
 		 This could occur when we follow a sign-extend by a right
@@ -4823,6 +4830,14 @@
       if (SET_DEST (x) == pc_rtx
 	  && GET_CODE (SET_SRC (x)) == LABEL_REF)
 	;
+      /* cut the reg propagation of stack-protected argument */
+      else if (x->volatil) {
+	rtx x1 = SET_DEST (x);
+	if (GET_CODE (x1) == SUBREG && GET_CODE (SUBREG_REG (x1)) == REG)
+	  x1 = SUBREG_REG (x1);
+	if (! REGNO_QTY_VALID_P(REGNO (x1)))
+	  make_new_qty (REGNO (x1), GET_MODE (x1));
+      }
 
       /* Don't count call-insns, (set (reg 0) (call ...)), as a set.
 	 The hard function value register is used only once, to copy to
